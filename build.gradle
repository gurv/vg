buildscript {
    ext {
        springBootVersion = '2.0.0.M7'
    }
    repositories {
        mavenCentral()
        jcenter()
        maven { url "https://repo.spring.io/milestone" }
        maven { url 'http://repo.spring.io/plugins-release' }
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
    }
}

def databaseProject = project(':database')

def javaProjects() {
    subprojects - project(':web') - project(':database') - project(':documentation')
}

configure(rootProject) {
    ext {
        dockerTaskGroup = 'Docker'
    }

    task upDockerCompose(type: Exec) {
        group = rootProject.dockerTaskGroup
        commandLine "docker-compose", "up"
    }
}

configure(subprojects) {
    ext {
        buildNoString = project.hasProperty('buildNo') ? "${buildNo}" : "0.1.0"
    }

    group = 'ru.gurv.vg'
    version = buildNoString
}

configure(subprojects - databaseProject) {
    task pushDockerImage(type: Exec) {
        group = rootProject.dockerTaskGroup
        commandLine "docker", "push", "gurv/$rootProject.name-$project.name"
    }

    task runDockerImage(type: Exec) {
        group = rootProject.dockerTaskGroup
        if (project.hasProperty("dockerPort")) {
            commandLine "docker", "run", "-i", "-p", "$project.dockerPort:$project.dockerPort", "gurv/$rootProject.name-$project.name:$version"
        } else {
            commandLine "docker", "run", "-i", "gurv/$rootProject.name-$project.name:latest"
        }
    }
}

configure(javaProjects()) {
    apply plugin: 'java'
    apply plugin: 'org.springframework.boot'
    apply plugin: 'io.spring.dependency-management'

    sourceCompatibility = '1.8'

    repositories {
        mavenCentral()
        maven { url "https://repo.spring.io/milestone" }
    }

    ext {
        springCloudVersion = 'Finchley.M5'
        springCloudNetflixVersion = '2.0.0.M5'
        springSecurityVersion = '5.0.0.RELEASE'
        springSecurityOAuthVersion = '2.2.1.RELEASE'
        springSecurityJwtVersion = '1.0.9.RELEASE'
    }

    jar {
        baseName = rootProject.name + '-' + baseName
    }

    bootJar {
        excludeDevtools = true
    }

    dependencyManagement {
        imports {
            mavenBom "org.springframework.security:spring-security-bom:$springSecurityVersion"
            mavenBom "org.springframework.cloud:spring-cloud-dependencies:$springCloudVersion"
            mavenBom "org.springframework.cloud:spring-cloud-netflix:$springCloudNetflixVersion"
        }
        dependencies {
            dependency "org.springframework.cloud:spring-cloud-netflix-sidecar:$springCloudNetflixVersion"
            dependency "org.springframework.security.oauth:spring-security-oauth2:$springSecurityOAuthVersion"
            dependency "org.springframework.security:spring-security-jwt:$springSecurityJwtVersion"
        }
    }

    task buildDockerImage(type: Exec) {
        dependsOn build
        group = rootProject.dockerTaskGroup

        def dockerDir = "$project.buildDir/docker"

        commandLine "docker", "build", "-t", "gurv/$rootProject.name-$project.name:latest", "$dockerDir"

        doFirst {
            copy {
                from('src/main/docker') {
                    include 'Dockerfile'
                }
                from("$project.buildDir/libs") {
                    include "$jar.archiveName"
                }
                into "$dockerDir"
                rename("$jar.archiveName", 'app.jar')
            }
        }
    }
}

class Dockerfile extends DefaultTask {

    def dockerfileInfo = ""
    def dockerDir = "$project.buildDir/docker"
    def dockerfileDestination = "$project.buildDir/docker/Dockerfile"
    def filesToCopy = []

    File getDockerfileDestination() {
        project.file(dockerfileDestination)
    }

    def from(image = "java") {
        dockerfileInfo += "FROM $image\r\n"
    }

    def maintainer(contact) {
        dockerfileInfo += "MAINTAINER $contact\r\n"
    }

    def add(sourceLocation, targetLocation) {
        filesToCopy << sourceLocation
        def file = project.file(sourceLocation)
        dockerfileInfo += "ADD $file.name ${targetLocation}\r\n"
    }

    def run(command) {
        dockerfileInfo += "RUN $command\r\n"
    }

    def volume(path) {
        dockerfileInfo += "VOLUME $path\r\n"
    }

    def env(var, value) {
        dockerfileInfo += "ENV $var $value\r\n"
    }

    def expose(port) {
        dockerfileInfo += "EXPOSE $port\r\n"
    }

    def workdir(dir) {
        dockerfileInfo += "WORKDIR $dir\r\n"
    }

    def cmd(command) {
        dockerfileInfo += "CMD $command\r\n"
    }

    def entrypoint(command) {
        dockerfileInfo += "ENTRYPOINT $command\r\n"
    }

    @TaskAction
    def writeDockerfile() {
        for (fileName in filesToCopy) {
            def source = project.file(fileName)
            def target = project.file("$dockerDir/$source.name")
            target.parentFile.mkdirs()
            target.delete()
            target << source.bytes
        }
        def file = getDockerfileDestination()
        file.parentFile.mkdirs()
        file.write dockerfileInfo
    }
}